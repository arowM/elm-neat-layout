module Neat.View exposing
    ( View
    , map
    , textBlock
    , fromTexts
    , row
    , Row
    , defaultRow
    , enableWrap
    , RowItem
    , alignCenter
    , alignRight
    , rowItem
    , topItem
    , middleItem
    , bottomItem
    , grownRowItem
    , grownTopItem
    , grownMiddleItem
    , grownBottomItem
    , column
    , Column
    , defaultColumn
    , ColumnItem
    , alignMiddle
    , alignBottom
    , columnItem
    , leftItem
    , centerItem
    , rightItem
    , grownColumnItem
    , grownLeftItem
    , grownCenterItem
    , grownRightItem
    , none
    , when
    , unless
    , withMaybe
    , expandGap
    , setBoundary
    , setNodeName
    , setRole
    , setAria
    , setBoolAria
    )

{-| Module for building `View`.


# Core

@docs View
@docs map


# Inline Texts

@docs textBlock
@docs fromTexts


# Row

@docs row


## Config

@docs Row
@docs defaultRow
@docs enableWrap
@docs RowItem
@docs alignCenter
@docs alignRight


## Item

Each function has the `String` argument, which helps make the DOM modifications more efficient. It must be unique among items in the same row.

@docs rowItem
@docs topItem
@docs middleItem
@docs bottomItem
@docs grownRowItem
@docs grownTopItem
@docs grownMiddleItem
@docs grownBottomItem


# Column

@docs column


## Config

@docs Column
@docs defaultColumn
@docs ColumnItem
@docs alignMiddle
@docs alignBottom


## Item

Each function has the `String` argument, which helps make the DOM modifications more efficient. It must be unique among items in the same row.

@docs columnItem
@docs leftItem
@docs centerItem
@docs rightItem
@docs grownColumnItem
@docs grownLeftItem
@docs grownCenterItem
@docs grownRightItem


# Handle Conditions

@docs none
@docs when
@docs unless
@docs withMaybe


# Expand Gaps

@docs expandGap


# Convert to `Boundary`

@docs setBoundary


# Lower level functions for HTML

@docs setNodeName
@docs setRole
@docs setAria
@docs setBoolAria

-}

import Mixin
import Neat.Internal as Internal
    exposing
        ( Alignment(..)
        , Boundary(..)
        , Boundary_(..)
        , Children(..)
        , Column(..)
        , ColumnItem(..)
        , Column_
        , Gap
        , IsGap(..)
        , Item_
        , Justify(..)
        , Row(..)
        , RowItem(..)
        , Row_
        , View(..)
        , View_(..)
        )
import Neat.Text as Text exposing (Text)



-- Core


{-| A gap-sensible `Html msg` alternative.
-}
type alias View gap msg =
    Internal.View gap msg


{-| -}
map : (a -> b) -> View gap a -> View gap b
map f =
    liftInternal (Internal.mapView_ f)


liftInternal : (View_ a -> View_ b) -> View g1 a -> View g2 b
liftInternal f view =
    case view of
        None ->
            None

        View view_ ->
            View <| f view_


extractNominalGap : View_ msg -> Gap
extractNominalGap view =
    case view of
        FromBoundary g _ _ ->
            g

        FromRow o ->
            o.nominalGap

        FromColumn o ->
            o.nominalGap

        FromTexts o ->
            o.nominalGap


defaultRow_ : Gap -> Children msg -> Row_ msg
defaultRow_ gap children =
    { mixin = Mixin.none
    , nominalGap = gap
    , contentGap = gap
    , nodeName = "div"
    , justifyContent = JustifyStart
    , children = children
    , wrap = False
    }


defaultColumn_ : Gap -> Children msg -> Column_ msg
defaultColumn_ gap children =
    { mixin = Mixin.none
    , nominalGap = gap
    , contentGap = gap
    , nodeName = "div"
    , justifyContent = JustifyStart
    , children = children
    }



-- Primitive Constructors


{-| Generates a view that displays a text string.

The first argument specifies the line height, which is the size of the gap between text lines when the given text is wrapped.

It is an alias for `\str -> fromTexts gap [ Neat.Text.fromString str ]`.

Note that `textBlock gap ""` does not generate anything.

-}
textBlock :
    IsGap gap
    -> String
    -> View gap msg
textBlock gap str =
    fromTexts gap
        [ Text.fromString str
        ]


{-| Build a text block from `Text`s.

Unlike a `row` consist of `textBlock`s, the `fromTexts` generates a single coherent sentence.

Say you have the following code:

    row
        defaultRow
        [ textBlock myLineHeight
            "foo bar baz"
        , textBlock myLineHeight
            "a b c d e f"
        ]

The resulting View will be newlined as follows:

    | foo bar | a b c d |
    | baz     | e f     |

In contrast, the View generated by the following code behaves a bit differently:

    import Neat.Text as Text

    fromTexts
        [ Text.text "foo bar baz"
        , Text.text "a b c d e f"
        ]

The resulting View will be newlined as follows:

    | foo bar baz a b c |
    | d e f             |

Note that `fromTexts gap []` does not generate anything.

-}
fromTexts :
    IsGap gap
    -> List (Text msg)
    -> View gap msg
fromTexts (IsGap gap) ls =
    let
        texts =
            List.filter (\a -> a.text /= "") ls
    in
    case texts of
        [] ->
            None

        item :: items ->
            View <|
                FromTexts
                    { mixin = Mixin.none
                    , nominalGap = gap
                    , contentGap = gap
                    , nodeName = "div"
                    , texts = ( item, items )
                    }



-- Row


{-| Align children horizontally.
-}
row : Row -> List (RowItem gap msg) -> View gap msg
row (Row { justify, wrap }) children_ =
    let
        children =
            children_
                |> List.filterMap
                    (\item ->
                        case item of
                            NoneRowItem ->
                                Nothing

                            RowItem item_ ->
                                Just item_
                    )
    in
    case children of
        [] ->
            None

        item :: items ->
            let
                row_ =
                    defaultRow_ itemGap (Children item items)

                itemGap =
                    extractNominalGap item.content
            in
            View <|
                FromRow
                    { row_
                        | justifyContent = justify
                        , wrap = wrap
                    }


{-| -}
type alias Row =
    Internal.Row


{-| Default setting for rows.

  - HTML node name: `"div"`
  - horizontal alignment: left
  - wrapping: disabled
  - role: no role
  - ARIA attributes: no attributes

-}
defaultRow : Row
defaultRow =
    Row
        { nodeName = "div"
        , justify = JustifyStart
        , wrap = False
        }


{-| -}
enableWrap : Row -> Row
enableWrap (Row config) =
    Row
        { config | wrap = True }


{-| -}
type alias RowItem gap msg =
    Internal.RowItem gap msg


{-| -}
alignCenter : Row -> Row
alignCenter (Row config) =
    Row
        { config | justify = JustifyCenter }


{-| -}
alignRight : Row -> Row
alignRight (Row config) =
    Row
        { config | justify = JustifyEnd }


{-| Row item with stretched height.
-}
rowItem : String -> View gap msg -> RowItem gap msg
rowItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignStretch
            , grow = False
            , key = key
            , content = view_
            }


rowItem_ : (View_ msg -> Item_ msg) -> View gap msg -> RowItem gap msg
rowItem_ f view =
    case view of
        None ->
            NoneRowItem

        View view_ ->
            RowItem <| f view_


{-| Row item with stretched height and width.
-}
grownRowItem : String -> View gap msg -> RowItem gap msg
grownRowItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignStretch
            , grow = True
            , key = key
            , content = view_
            }


{-| Top-aligned item.
-}
topItem : String -> View gap msg -> RowItem gap msg
topItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignStart
            , grow = False
            , key = key
            , content = view_
            }


{-| Top-aligned item which grows its width as much as possible.
-}
grownTopItem : String -> View gap msg -> RowItem gap msg
grownTopItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignStart
            , grow = True
            , key = key
            , content = view_
            }


{-| Vertically centered item.
-}
middleItem : String -> View gap msg -> RowItem gap msg
middleItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignCenter
            , grow = False
            , key = key
            , content = view_
            }


{-| Vertically centered item which grows its width as much as possible.
-}
grownMiddleItem : String -> View gap msg -> RowItem gap msg
grownMiddleItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignCenter
            , grow = True
            , key = key
            , content = view_
            }


{-| Bottom-aligned item.
-}
bottomItem : String -> View gap msg -> RowItem gap msg
bottomItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignEnd
            , grow = False
            , key = key
            , content = view_
            }


{-| Bottom-aligned item which grows its width as much as possible.
-}
grownBottomItem : String -> View gap msg -> RowItem gap msg
grownBottomItem key =
    rowItem_ <|
        \view_ ->
            { alignSelf = AlignEnd
            , grow = True
            , key = key
            , content = view_
            }



-- Column


{-| Align children vertically.
-}
column : Column -> List (ColumnItem gap msg) -> View gap msg
column (Column { justify }) children_ =
    let
        children =
            children_
                |> List.filterMap
                    (\item ->
                        case item of
                            NoneColumnItem ->
                                Nothing

                            ColumnItem item_ ->
                                Just item_
                    )
    in
    case children of
        [] ->
            None

        item :: items ->
            let
                column_ =
                    defaultColumn_
                        itemGap
                        (Children item items)

                itemGap =
                    extractNominalGap item.content
            in
            View <|
                FromColumn
                    { column_
                        | justifyContent = justify
                    }


{-| -}
type alias Column =
    Internal.Column


{-| Default setting for columns.

  - HTML node name: `"div"`
  - vertical alignment: top

-}
defaultColumn : Column
defaultColumn =
    Column
        { nodeName = "div"
        , justify = JustifyStart
        }


{-| -}
type alias ColumnItem gap msg =
    Internal.ColumnItem gap msg


{-| -}
alignMiddle : Column -> Column
alignMiddle (Column config) =
    Column
        { config | justify = JustifyCenter }


{-| -}
alignBottom : Column -> Column
alignBottom (Column config) =
    Column
        { config | justify = JustifyEnd }


columnItem_ : (View_ msg -> Item_ msg) -> View gap msg -> ColumnItem gap msg
columnItem_ f view =
    case view of
        None ->
            NoneColumnItem

        View view_ ->
            ColumnItem <| f view_


{-| Column item with stretched width.
-}
columnItem : String -> View gap msg -> ColumnItem gap msg
columnItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignStretch
            , grow = False
            , key = key
            , content = view_
            }


{-| Column item with stretched width and height.
-}
grownColumnItem : String -> View gap msg -> ColumnItem gap msg
grownColumnItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignStretch
            , grow = True
            , key = key
            , content = view_
            }


{-| Left-aligned item.
-}
leftItem : String -> View gap msg -> ColumnItem gap msg
leftItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignStart
            , grow = False
            , key = key
            , content = view_
            }


{-| Left-aligned item which grows its height as much as possible.
-}
grownLeftItem : String -> View gap msg -> ColumnItem gap msg
grownLeftItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignStart
            , grow = True
            , key = key
            , content = view_
            }


{-| Horizontally centered item.
-}
centerItem : String -> View gap msg -> ColumnItem gap msg
centerItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignCenter
            , grow = False
            , key = key
            , content = view_
            }


{-| Horizontally centered item which grows its height as much as possible.
-}
grownCenterItem : String -> View gap msg -> ColumnItem gap msg
grownCenterItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignCenter
            , grow = True
            , key = key
            , content = view_
            }


{-| Right-aligned item.
-}
rightItem : String -> View gap msg -> ColumnItem gap msg
rightItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignEnd
            , grow = False
            , key = key
            , content = view_
            }


{-| Right-aligned item which grows its height as much as possible.
-}
grownRightItem : String -> View gap msg -> ColumnItem gap msg
grownRightItem key =
    columnItem_ <|
        \view_ ->
            { alignSelf = AlignEnd
            , grow = True
            , key = key
            , content = view_
            }



-- Handle conditions


{-| Generates no HTML nodes.
This is useful for handling elements which only appears under certain conditions.

    when p v =
        if p then
            v

        else
            none

-}
none : View g a
none =
    None


{-| Insert a view only when a condition is met.
-}
when : Bool -> View gap msg -> View gap msg
when p v =
    if p then
        v

    else
        none


{-| Insert a view unless a condition is met.
-}
unless : Bool -> View gap msg -> View gap msg
unless p =
    when <| not p


{-| Insert a view only if the given value is `Just`.
-}
withMaybe : Maybe a -> (a -> View gap msg) -> View gap msg
withMaybe ma f =
    case ma of
        Just a ->
            f a

        Nothing ->
            none



-- Expand Gaps


{-| Expand View Gap to a wider one.

You can use `expandGap` to "shrink" Gaps, but we do not recommend doing so. Such layouts must not be "neat"!

-}
expandGap : IsGap g2 -> View g1 msg -> View g2 msg
expandGap (IsGap g2) view =
    case view of
        None ->
            None

        View view_ ->
            View <|
                case view_ of
                    FromBoundary _ props boundary ->
                        FromBoundary g2 props boundary

                    FromRow row_ ->
                        FromRow { row_ | nominalGap = g2 }

                    FromColumn column_ ->
                        FromColumn { column_ | nominalGap = g2 }

                    FromTexts texts_ ->
                        FromTexts { texts_ | nominalGap = g2 }



-- Convert to `Boundary`


{-| Wrap a view with boundary.
This is the only way to reset view gaps.
-}
setBoundary : View gap msg -> Boundary msg
setBoundary view =
    case view of
        None ->
            NoneBoundary

        View view_ ->
            Boundary
                Internal.defaultBoundaryProps
                (FromView
                    { content = view_
                    }
                )



-- Lower level functions for HTML


{-| Overrides the node name of the outermost HTML element.

For Views created with `Neat.Boundary.setGap`, overwrite the node name of the original Boundary:

    import Neat.Boundary as Boundary exposing (Boundary)
    import Neat.View as View exposing (View)

    sampleBoundary : Boundary msg
    sampleBoundary =
        Debug.todo "Sample"

    sampleView : View SampleGap msg
    sampleView =
        sampleBoundary
            |> Boundary.setGap sampleGap
            |> View.setNodeName "section"

    -- `sampleView2` is equivalent to `sampleView`.
    sampleView2 : View SampleGap msg
    sampleView2 =
        sampleBoundary
            |> Boundary.setNodeName "section"
            |> Boundary.setGap sampleGap

-}
setNodeName : String -> View gap msg -> View gap msg
setNodeName str view =
    case view of
        View (FromBoundary g props boundary_) ->
            View <|
                FromBoundary g
                    { props | nodeName = str }
                    boundary_

        View (FromRow row_) ->
            View <|
                FromRow
                    { row_ | nodeName = str }

        View (FromColumn column_) ->
            View <|
                FromColumn
                    { column_ | nodeName = str }

        View (FromTexts texts_) ->
            View <|
                FromTexts
                    { texts_ | nodeName = str }

        None ->
            None


{-| Set the WAI-ARIA `role` attribute value of the outermost HTML element.

For Views created with `Neat.Boundary.setGap`, append the attribute to the original Boundary.

-}
setRole : String -> View gap msg -> View gap msg
setRole str view =
    case view of
        View (FromBoundary g props boundary_) ->
            View <|
                FromBoundary g
                    { props
                        | mixin =
                            Mixin.batch
                                [ props.mixin
                                , Mixin.attribute "role" str
                                ]
                    }
                    boundary_

        View (FromRow row_) ->
            View <|
                FromRow
                    { row_
                        | mixin =
                            Mixin.batch
                                [ row_.mixin
                                , Mixin.attribute "role" str
                                ]
                    }

        View (FromColumn column_) ->
            View <|
                FromColumn
                    { column_
                        | mixin =
                            Mixin.batch
                                [ column_.mixin
                                , Mixin.attribute "role" str
                                ]
                    }

        View (FromTexts texts_) ->
            View <|
                FromTexts
                    { texts_
                        | mixin =
                            Mixin.batch
                                [ texts_.mixin
                                , Mixin.attribute "role" str
                                ]
                    }

        None ->
            None


{-| Set the WAI-ARIA `aria-*` attribute value of the outermost HTML element.

For Views created with `Neat.Boundary.setGap`, append the attribute to the original Boundary.

e.g., `setAria "required" "true"` stands for "aria-required" is "true".

-}
setAria : String -> String -> View gap msg -> View gap msg
setAria name v view =
    case view of
        View (FromBoundary g props boundary_) ->
            View <|
                FromBoundary g
                    { props
                        | mixin =
                            Mixin.batch
                                [ props.mixin
                                , Mixin.attribute ("aria-" ++ name) v
                                ]
                    }
                    boundary_

        View (FromRow row_) ->
            View <|
                FromRow
                    { row_
                        | mixin =
                            Mixin.batch
                                [ row_.mixin
                                , Mixin.attribute ("aria-" ++ name) v
                                ]
                    }

        View (FromColumn column_) ->
            View <|
                FromColumn
                    { column_
                        | mixin =
                            Mixin.batch
                                [ column_.mixin
                                , Mixin.attribute ("aria-" ++ name) v
                                ]
                    }

        View (FromTexts texts_) ->
            View <|
                FromTexts
                    { texts_
                        | mixin =
                            Mixin.batch
                                [ texts_.mixin
                                , Mixin.attribute ("aria-" ++ name) v
                                ]
                    }

        None ->
            None


{-| Helper function to set boolean WAI-ARIA `aria-*` attribute value of the outermost HTML element.

i.e.,

  - `setBoolAria name True` is equal to `setAria name "true"`
  - `setBoolAria name False` is equal to `setAria name "false"`

-}
setBoolAria : String -> Bool -> View gap msg -> View gap msg
setBoolAria name p =
    setAria name <|
        if p then
            "true"

        else
            "false"
